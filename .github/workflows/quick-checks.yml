name: Quick Checks

on:
  pull_request:
    branches: [a5c/main, main]
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: quick-checks-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  pr-fast:
    name: Lint, Typecheck, Unit Tests, Filenames, Actionlint, EditorConfig
    runs-on: ubuntu-latest
    timeout-minutes: 7
    env:
      # Optional Codecov token; when empty, upload step is skipped
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN || vars.CODECOV_TOKEN || '' }}
      # Pinned validator tools used for example validation
      AJV_CLI_VERSION: "5.0.0" # ajv-cli v5 (Ajv v8, Draft 2020-12)
      AJV_FORMATS_VERSION: "3.0.1" # ajv-formats v3 for Ajv v8
      # Pin editorconfig-checker with override via repo Variable
      # Default 5.1.9 (supports -format github-actions); script detects support dynamically
      EDITORCONFIG_CHECKER_VERSION: ${{ vars.EDITORCONFIG_CHECKER_VERSION || '5.1.9' }}
      # Enable hard coverage gate by default for PRs targeting a5c/main,
      # with maintainer override via repo variable (set REQUIRE_COVERAGE='false').
      # For other PRs, respect repo variable as-is (opt-in).
      REQUIRE_COVERAGE: ${{ (github.event_name == 'pull_request' && github.base_ref == 'a5c/main' && vars.REQUIRE_COVERAGE != 'false') && 'true' || (vars.REQUIRE_COVERAGE || '') }}
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: npm
      - name: Install
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm install; fi
      - name: Lint (eslint)
        run: npm run -s lint
      - name: Lint (filenames)
        run: npm run -s lint:filenames
      - name: Validate GitHub Workflows (actionlint)
        env:
          REQUIRE_ACTIONLINT: ${{ vars.REQUIRE_ACTIONLINT || '' }}
        run: |
          bash scripts/ci-actionlint.sh
      - name: Check EditorConfig compliance
        run: |
          bash scripts/ci-editorconfig.sh
      - name: Observability schema path guard
        run: bash scripts/lint-obs-paths.sh
      - name: Typecheck (tsc --noEmit)
        run: npm run -s typecheck
      - name: Guard focused/skipped tests (.only/.skip)
        run: bash scripts/lint-tests-focused.sh
      - name: Unit tests (vitest)
        run: npm run -s test:ci
      - name: Validate offline stub example (NE schema)
        run: |
          node dist/cli.js validate \
            --in docs/examples/enrich.offline.stub.json \
            --schema docs/specs/ne.schema.json \
            --quiet
      - name: Example validation (NE schema) â€” ajv-cli with fallback
        shell: bash
        run: |
          set -euo pipefail
          # Build CLI if not already built by previous steps
          npm run -s build
          # Produce a sample NE JSON from a known fixture
          node dist/cli.js normalize \
            --in samples/workflow_run.completed.json \
            --out /tmp/out.ne.json
          echo "Attempting ajv-cli@${AJV_CLI_VERSION} validation (ajv-formats)"
          if ! npx -y ajv-cli@"${AJV_CLI_VERSION}" validate \
              -s docs/specs/ne.schema.json \
              -d /tmp/out.ne.json \
              --spec=draft2020 \
              -c ajv-formats; then
            echo "ajv-cli unavailable or failed; falling back to built-in CLI validator"
            node dist/cli.js validate \
              --in /tmp/out.ne.json \
              --schema docs/specs/ne.schema.json \
              --quiet
          fi
      - name: Validate example enrich outputs (schema + parse)
        run: |
          set -euo pipefail
          # jq parse check
          jq -e type docs/examples/enrich.offline.json >/dev/null
          jq -e type docs/examples/enrich.online.json >/dev/null
          # validate against NE schema (offline may omit enriched.github)
          npx -y ajv-cli@5.0.0 validate -s docs/specs/ne.schema.json -d docs/examples/enrich.offline.json --spec=draft2020 -c ajv-formats
          npx -y ajv-cli@5.0.0 validate -s docs/specs/ne.schema.json -d docs/examples/enrich.online.json --spec=draft2020 -c ajv-formats
      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-lcov
          path: |
            coverage/lcov.info
            coverage/coverage-summary.json
          if-no-files-found: ignore
      # Single optional Codecov upload guarded by token
      - name: Coverage summary
        if: always()
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            node -e '
              const fs = require("fs");
              const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
              const t = sum.total || {};
              const row = (k) => `| ${k} | ${((t[k]?.pct ?? 0)).toFixed(2)}% | ${t[k]?.covered ?? 0}/${t[k]?.total ?? 0} |`;
              const out = [
                "## Coverage Summary",
                "",
                "| Metric | Percent | Covered/Total |",
                "|---|---:|---:|",
                row("lines"),
                row("statements"),
                row("functions"),
                row("branches"),
                "",
              ].join("\n");
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, out);
            ';
          else
            echo "coverage/coverage-summary.json not found; ensure vitest json-summary reporter is enabled" >> "$GITHUB_STEP_SUMMARY";
          fi
      - name: Upload to Codecov (optional)
        # Upload to Codecov only when CODECOV_TOKEN is configured
        if: env.CODECOV_TOKEN != ''
        uses: codecov/codecov-action@v5
        with:
          token: ${{ env.CODECOV_TOKEN }}
          files: |
            coverage/lcov.info
          flags: pr
          fail_ci_if_error: false
          verbose: true
      - name: "Coverage gate (optional, REQUIRE_COVERAGE)"
        if: ${{ env.REQUIRE_COVERAGE == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "REQUIRE_COVERAGE=true -> enforcing thresholds from scripts/coverage-thresholds.json"
          if [ ! -f coverage/coverage-summary.json ]; then
            echo "::error title=Coverage Gate Failed::coverage/coverage-summary.json not found. Ensure tests generate coverage with json-summary reporter."
            exit 1
          fi
          if [ ! -f scripts/coverage-thresholds.json ]; then
            echo "::error title=Coverage Gate Failed::scripts/coverage-thresholds.json not found. Thresholds must be defined."
            exit 1
          fi
          read -r LINES_T BRANCHES_T FUNCS_T STMTS_T < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' scripts/coverage-thresholds.json)
          node -e '
            const fs = require("fs");
            const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
            const t = sum.total || {};
            const pct = {
              lines: Number((t.lines?.pct ?? 0).toFixed(2)),
              branches: Number((t.branches?.pct ?? 0).toFixed(2)),
              functions: Number((t.functions?.pct ?? 0).toFixed(2)),
              statements: Number((t.statements?.pct ?? 0).toFixed(2)),
            };
            fs.writeFileSync("/tmp/cov.json", JSON.stringify(pct));
          '
          read -r LINES_P BRANCHES_P FUNCS_P STMTS_P < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' /tmp/cov.json)
          cmp() { awk -v a="$1" -v b="$2" 'BEGIN{ if (a+0 < b+0) exit 1; else exit 0 }'; }
          FAILS=()
          cmp "$LINES_P" "$LINES_T" || FAILS+=("lines: ${LINES_P}% < ${LINES_T}%")
          cmp "$BRANCHES_P" "$BRANCHES_T" || FAILS+=("branches: ${BRANCHES_P}% < ${BRANCHES_T}%")
          cmp "$FUNCS_P" "$FUNCS_T" || FAILS+=("functions: ${FUNCS_P}% < ${FUNCS_T}%")
          cmp "$STMTS_P" "$STMTS_T" || FAILS+=("statements: ${STMTS_P}% < ${STMTS_T}%")
          {
            echo "## Coverage Gate"
            echo "REQUIRE_COVERAGE=true; failing when below thresholds"
            echo ""
            echo "| Metric | Actual | Threshold |"
            echo "|---|---:|---:|"
            printf "| Lines | %s%% | %s%% |\n" "$LINES_P" "$LINES_T"
            printf "| Branches | %s%% | %s%% |\n" "$BRANCHES_P" "$BRANCHES_T"
            printf "| Functions | %s%% | %s%% |\n" "$FUNCS_P" "$FUNCS_T"
            printf "| Statements | %s%% | %s%% |\n" "$STMTS_P" "$STMTS_T"
            if [ ${#FAILS[@]} -gt 0 ]; then
              echo ""
              echo "Failures: ${FAILS[*]}"
            else
              echo ""
              echo "All metrics meet or exceed thresholds."
            fi
          } | tee -a "$GITHUB_STEP_SUMMARY"
          if [ ${#FAILS[@]} -gt 0 ]; then
            echo "::error title=Coverage Gate Failed::Below thresholds for: ${FAILS[*]}"
            echo "Coverage below thresholds; failing per REQUIRE_COVERAGE=true" >&2
            exit 1
          fi

  docs-lint:
    name: Docs Lint (banned phrases)
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - uses: actions/checkout@v5
      - name: Check for banned phrase in docs (rg or grep)
        shell: bash
        run: |
          set -euo pipefail
          echo "Scanning markdown docs for banned phrase: composed[].payload := any"
          PATTERN='composed\\[\\]\\.payload[[:space:]]*[:=][[:space:]]*any'
          if command -v rg >/dev/null 2>&1; then
            # Use ripgrep if available; scan README and markdown under docs
            if rg -n -S -e 'composed\\[\\]\\.payload\\s*[:=]\\s*any' README.md docs/**/*.md; then
              echo "::error title=Docs Lint Failed::Found banned phrase 'composed[].payload: any' in docs. Update to 'object | array | null'."
              exit 1
            else
              echo "No banned phrases found."
            fi
          else
            # Fallback to grep scanning markdown only
            if grep -R -n -E "$PATTERN" -- README.md docs --include='*.md'; then
              echo "::error title=Docs Lint Failed::Found banned phrase 'composed[].payload: any' in docs. Update to 'object | array | null'."
              exit 1
            else
              echo "No banned phrases found."
            fi
          fi
