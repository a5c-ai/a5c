name: Tests

on:
  push:
    branches: [a5c/main, main]

jobs:
  unit:
    env:
      # Optional Codecov token; when empty, upload step is skipped
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN || vars.CODECOV_TOKEN || '' }}
    permissions:
      contents: read
      actions: read
      pull-requests: write
      issues: write
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        id: setup-node
        with:
          node-version-file: .nvmrc
          cache: "npm"
      - name: Init timings file
        run: |
          : > hotspots.jsonl
      - name: Parse cache restored bytes (best-effort)
        if: always()
        id: cache-bytes
        shell: bash
        run: |
          set -euo pipefail
          BYTES=0
          KEY=""
          if [ -f run.log ]; then
            BYTES=$(awk '/Cache Size:/ { m=match($0, /\(([0-9]+) B\)/, a); if(m){ print a[1]; exit } }' run.log || echo 0)
            KEY=$(awk -F ': ' '/Cache restored from key:/ { print $2; exit }' run.log || echo "")
          fi
          echo "CACHE_NODE_BYTES=${BYTES}" >> "$GITHUB_ENV"
          echo "CACHE_NODE_KEY=${KEY}" >> "$GITHUB_ENV"
      - name: Install
        run: |
          START=$(date +%s%3N)
          ./scripts/install.sh
          END=$(date +%s%3N)
          DUR=$((END-START))
          echo "{\"name\":\"Install\",\"duration_ms\":$DUR}" >> hotspots.jsonl
      - name: Build
        run: |
          START=$(date +%s%3N)
          ./scripts/build.sh
          END=$(date +%s%3N)
          DUR=$((END-START))
          echo "{\"name\":\"Build\",\"duration_ms\":$DUR}" >> hotspots.jsonl
      - name: Test
        run: |
          START=$(date +%s%3N)
          ./scripts/test.sh
          END=$(date +%s%3N)
          DUR=$((END-START))
          echo "{\"name\":\"Test\",\"duration_ms\":$DUR}" >> hotspots.jsonl
      - name: "CLI smoke: normalize | validate sample"
        run: |
          START=$(date +%s%3N)
          # build CLI if not already built by pretest
          npm run build --silent
          # normalize a sample and validate against the schema using built-in validator
          node dist/cli.js normalize \
            --in samples/workflow_run.completed.json \
            --out /tmp/out.validate.json
          node dist/cli.js validate \
            --in /tmp/out.validate.json \
            --schema docs/specs/ne.schema.json \
            --quiet
          END=$(date +%s%3N)
          DUR=$((END-START))
          echo "{\"name\":\"CLI smoke\",\"duration_ms\":$DUR}" >> hotspots.jsonl
      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: |
            coverage/lcov.info
            coverage/coverage-summary.json
          if-no-files-found: ignore
      - name: Upload coverage to Codecov (optional)
        if: env.CODECOV_TOKEN != ''
        uses: codecov/codecov-action@v5
        with:
          token: ${{ env.CODECOV_TOKEN }}
          files: |
            coverage/lcov.info
          flags: push
          fail_ci_if_error: false
          verbose: true
      - name: Upload JUnit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vitest-junit
          path: |
            junit.xml
          if-no-files-found: ignore
      # Keep a single Codecov upload (guarded by token)
      - name: Validate observability example against schema
        if: always()
        run: |
          node scripts/validate-observability.mjs
      # Removed duplicate Codecov upload step to avoid double uploads
      # Flaky tests detection (PR-only comment + label)
      - name: Flaky tests detection
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Generate summary JSON and PR markdown
          node scripts/flaky-detector.cjs \
            1>/tmp/flaky.json \
            2>/dev/null || true
          node -e '
            const fs = require("fs");
            const { execSync } = require("child_process");
            let res = { found: false, flakies: [] };
            try { res = JSON.parse(fs.readFileSync("/tmp/flaky.json","utf8")); } catch {}
            if (!res || !res.flakies) res = { found: false, flakies: [] };
            const isPR = process.env.GITHUB_EVENT_NAME === "pull_request";
            if (isPR) {
              const lines = [];
              lines.push("<!-- a5c:flaky-detector -->");
              lines.push("## ðŸ§ª Flaky Tests Summary");
              if (!res.found) {
                lines.push("No flaky tests detected (no mixed pass/fail across retries).");
              } else {
                lines.push("The following tests appear flaky (failures followed by passes within the run):\n");
                lines.push("| Test | File/Class | Attempts | Failed | Passed |");
                lines.push("|---|---|---:|---:|---:|");
                for (const f of res.flakies) {
                  const loc = f.file || f.classname || "";
                  const esc = s => String(s??'').replaceAll('|','\\|');
                  lines.push(`| ${esc(f.name)} | ${esc(loc)} | ${f.attempts} | ${f.failed_runs} | ${f.passed_runs} |`);
                }
              }
              fs.writeFileSync('/tmp/flaky.md', lines.join('\n'));
              const pr = JSON.parse(fs.readFileSync(process.env.GITHUB_EVENT_PATH,'utf8')).pull_request.number;
              const repo = process.env.GITHUB_REPOSITORY;
              // Ensure label exists and apply when flakies found
              const label = "flaky-test";
              try { execSync(`gh label view \"${label}\" --repo ${repo}`, { stdio: 'ignore' }); }
              catch { try { execSync(`gh label create \"${label}\" --color f9d0c4 --description \"Tests detected as flaky in CI\" --repo ${repo}`); } catch {}
              }
              try {
                if (res.found) execSync(`gh pr edit ${pr} --repo ${repo} --add-label \"${label}\"`, { stdio: 'ignore' });
              } catch {}
              // Upsert comment with stable marker
              try {
                const existing = execSync(`gh api repos/${repo}/issues/${pr}/comments --jq ".[] | select(.body | contains('a5c:flaky-detector')) | .id"`).toString().trim();
                if (existing) {
                  execSync(`gh api -X PATCH -H 'Accept: application/vnd.github+json' repos/${repo}/issues/comments/${existing} -f body@/tmp/flaky.md`);
                } else {
                  execSync(`gh pr comment ${pr} --repo ${repo} -F /tmp/flaky.md`);
                }
              } catch {}
            }
          '
      - name: Upload Vitest JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vitest-json
          path: |
            vitest-results.json
          if-no-files-found: ignore
      - name: Coverage summary
        if: always()
        run: |
          START=$(date +%s%3N)
          if [ -f coverage/coverage-summary.json ]; then
            node -e '
              const fs = require("fs");
              const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
              const t = sum.total || {};
              const row = (k) => `| ${k} | ${((t[k]?.pct ?? 0)).toFixed(2)}% | ${t[k]?.covered ?? 0}/${t[k]?.total ?? 0} |`;
              const out = [
                "## Coverage Summary",
                "",
                "| Metric | Percent | Covered/Total |",
                "|---|---:|---:|",
                row("lines"),
                row("statements"),
                row("functions"),
                row("branches"),
                "",
              ].join("\n");
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, out);
            ';
          else
            echo "coverage/coverage-summary.json not found; ensure vitest json-summary reporter is enabled" >> "$GITHUB_STEP_SUMMARY";
          fi
          END=$(date +%s%3N)
          DUR=$((END-START))
          echo "{\"name\":\"Coverage summary\",\"duration_ms\":$DUR}" >> hotspots.jsonl
      - name: Enforce coverage thresholds (optional hard gate)
        if: ${{ github.event_name == 'pull_request' && vars.REQUIRE_COVERAGE == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "REQUIRE_COVERAGE is true â€” enforcing coverage thresholds"
          if [ ! -f coverage/coverage-summary.json ]; then
            echo "coverage/coverage-summary.json not found; failing due to hard gate." >&2
            exit 1
          fi
          if [ -f scripts/coverage-thresholds.json ]; then
            read -r LINES_T BRANCHES_T FUNCS_T STMTS_T < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' scripts/coverage-thresholds.json)
          else
            LINES_T=60; BRANCHES_T=55; FUNCS_T=60; STMTS_T=60
          fi
          node -e '
            const fs = require("fs");
            const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
            const t = sum.total || {};
            const pct = {
              lines: Number((t.lines?.pct ?? 0).toFixed(2)),
              branches: Number((t.branches?.pct ?? 0).toFixed(2)),
              functions: Number((t.functions?.pct ?? 0).toFixed(2)),
              statements: Number((t.statements?.pct ?? 0).toFixed(2)),
            };
            fs.writeFileSync("/tmp/cov.json", JSON.stringify(pct));
          '
          read -r LINES_P BRANCHES_P FUNCS_P STMTS_P < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' /tmp/cov.json)
          cmp() { awk -v a="$1" -v b="$2" 'BEGIN{ if (a+0 < b+0) exit 1; else exit 0 }'; }
          FAILS=()
          cmp "$LINES_P" "$LINES_T" || FAILS+=("lines: ${LINES_P}% < ${LINES_T}%")
          cmp "$BRANCHES_P" "$BRANCHES_T" || FAILS+=("branches: ${BRANCHES_P}% < ${BRANCHES_T}%")
          cmp "$FUNCS_P" "$FUNCS_T" || FAILS+=("functions: ${FUNCS_P}% < ${FUNCS_T}%")
          cmp "$STMTS_P" "$STMTS_T" || FAILS+=("statements: ${STMTS_P}% < ${STMTS_T}%")
          {
            echo "## Coverage Gate"
            echo "REQUIRE_COVERAGE=true; failing when below thresholds"
            echo ""
            echo "| Metric | Actual | Threshold |"
            echo "|---|---:|---:|"
            printf "| Lines | %s%% | %s%% |\n" "$LINES_P" "$LINES_T"
            printf "| Branches | %s%% | %s%% |\n" "$BRANCHES_P" "$BRANCHES_T"
            printf "| Functions | %s%% | %s%% |\n" "$FUNCS_P" "$FUNCS_T"
            printf "| Statements | %s%% | %s%% |\n" "$STMTS_P" "$STMTS_T"
            if [ ${#FAILS[@]} -gt 0 ]; then
              echo ""
              echo "Failures: ${FAILS[*]}"
            fi
          } | tee -a "$GITHUB_STEP_SUMMARY"
          if [ ${#FAILS[@]} -gt 0 ]; then
            echo "Coverage below thresholds; failing per REQUIRE_COVERAGE=true" >&2
            exit 1
          fi
      - name: "PR feedback: coverage thresholds -> comment + labels"
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ ! -f coverage/coverage-summary.json ]; then
            echo "No coverage summary found; skipping PR feedback." >&2
            exit 0
          fi
          # Read thresholds from scripts/coverage-thresholds.json when present; fallback to defaults
          if [ -f scripts/coverage-thresholds.json ]; then
            read -r LINES_T BRANCHES_T FUNCS_T STMTS_T < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' scripts/coverage-thresholds.json)
          else
            LINES_T=60
            BRANCHES_T=55
            FUNCS_T=60
            STMTS_T=60
          fi
          # Parse actuals
          node -e '
            const fs = require("fs");
            const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
            const t = sum.total || {};
            const pct = {
              lines: Number((t.lines?.pct ?? 0).toFixed(2)),
              branches: Number((t.branches?.pct ?? 0).toFixed(2)),
              functions: Number((t.functions?.pct ?? 0).toFixed(2)),
              statements: Number((t.statements?.pct ?? 0).toFixed(2)),
            };
            fs.writeFileSync("/tmp/cov.json", JSON.stringify(pct));
          '
          read -r LINES_P BRANCHES_P FUNCS_P STMTS_P < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' /tmp/cov.json)
          FAILS=()
          cmp() { awk -v a="$1" -v b="$2" 'BEGIN{ if (a+0 < b+0) exit 1; else exit 0 }'; }
          cmp "$LINES_P" "$LINES_T" || FAILS+=("lines")
          cmp "$BRANCHES_P" "$BRANCHES_T" || FAILS+=("branches")
          cmp "$FUNCS_P" "$FUNCS_T" || FAILS+=("functions")
          cmp "$STMTS_P" "$STMTS_T" || FAILS+=("statements")
          STATUS=ok
          if [ ${#FAILS[@]} -gt 0 ]; then STATUS=low; fi
          LABEL_OK="coverage:ok"
          LABEL_LOW="coverage:low"
          PR_NUMBER=$(jq -r .pull_request.number < "$GITHUB_EVENT_PATH")
          REPO_FULL=${GITHUB_REPOSITORY}
          # Ensure labels exist
          gh label list --repo "$REPO_FULL" >/dev/null 2>&1 || true
          for L in "$LABEL_OK" "$LABEL_LOW"; do
            if ! gh label view "$L" --repo "$REPO_FULL" >/dev/null 2>&1; then
              gh label create "$L" --color $( [ "$L" = "$LABEL_OK" ] && echo 2eb886 || echo e11d21 ) --description "Test coverage ${L#coverage:}" --repo "$REPO_FULL" || true
            fi
          done
          # Update labels on PR
          if [ "$STATUS" = ok ]; then
            gh pr edit "$PR_NUMBER" --repo "$REPO_FULL" --add-label "$LABEL_OK" --remove-label "$LABEL_LOW" 2>/dev/null || true
          else
            gh pr edit "$PR_NUMBER" --repo "$REPO_FULL" --add-label "$LABEL_LOW" --remove-label "$LABEL_OK" 2>/dev/null || true
          fi
          # Prepare PR comment body with stable marker
          {
            echo "<!-- a5c:coverage-feedback -->"
            echo "## ðŸ§ª Coverage Feedback"
            echo "Status: ${STATUS}"
            echo ""
            echo "| Metric | Actual | Threshold |"
            echo "|---|---:|---:|"
            printf "| Lines | %s%% | %s%% |\n" "$LINES_P" "$LINES_T"
            printf "| Branches | %s%% | %s%% |\n" "$BRANCHES_P" "$BRANCHES_T"
            printf "| Functions | %s%% | %s%% |\n" "$FUNCS_P" "$FUNCS_T"
            printf "| Statements | %s%% | %s%% |\n" "$STMTS_P" "$STMTS_T"
            echo ""
            echo "_Automated feedback from Tests workflow._"
          } > /tmp/pr-comment.md
          # Find existing comment with marker and update; otherwise create
          existing_id=$(gh api \
            repos/${REPO_FULL}/issues/${PR_NUMBER}/comments \
            --jq '.[] | select(.body | contains("a5c:coverage-feedback")) | .id' || true)
          if [ -n "$existing_id" ]; then
            gh api \
              -X PATCH \
              -H "Accept: application/vnd.github+json" \
              repos/${REPO_FULL}/issues/comments/${existing_id} \
              -f body@/tmp/pr-comment.md >/dev/null
          else
            gh pr comment "$PR_NUMBER" --repo "$REPO_FULL" -F /tmp/pr-comment.md >/dev/null
          fi
      - name: Observability summary
        if: always()
        uses: ./.github/actions/obs-summary
        env:
          OBS_FILE: observability.json
          # Pin schema version in produced artifact
          SCHEMA_VERSION: 0.1
          # Pass cache hit from setup-node to the action as CACHE_NODE_HIT
          CACHE_NODE_HIT: ${{ steps.setup-node.outputs.cache-hit }}
          # Include conclusion and run start time for duration
          CONCLUSION: ${{ job.status }}
          RUN_STARTED_AT: ${{ github.run_started_at }}
      - name: Step hotspots summary and annotations
        if: always()
        uses: ./.github/actions/step-hotspots
        with:
          top_n: "5"
          warn_ms: "60000"
          error_ms: "180000"
          upload_artifact: "false"
          summary_title: "CI Step Hotspots"
      - name: Step hotspots summary
        if: always()
        uses: ./.github/actions/step-hotspots
        with:
          warn_ms: 300000
          error_ms: 900000
          p95_warn_ms: 420000
          p95_error_ms: 1200000
          top_n: 10

  aggregate:
    name: Aggregate Observability
    needs: [unit]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Download & aggregate
        uses: ./.github/actions/obs-aggregate
      - name: Show aggregate
        run: |
          echo "## Aggregate observability" >> "$GITHUB_STEP_SUMMARY"
          jq '.metrics.cache' observability.aggregate.json | tee -a "$GITHUB_STEP_SUMMARY"
