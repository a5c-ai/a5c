name: Tests

on:
  push:
    branches: [a5c/main, main]

jobs:
  unit:
    permissions:
      contents: read
      actions: read
      pull-requests: write
      issues: write
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Parse cache restored bytes (best-effort)
        if: always()
        id: cache-bytes
        shell: bash
        run: |
          set -euo pipefail
          BYTES=0
          KEY=""
          if [ -f run.log ]; then
            BYTES=$(awk '/Cache Size:/ { m=match($0, /\(([0-9]+) B\)/, a); if(m){ print a[1]; exit } }' run.log || echo 0)
            KEY=$(awk -F ': ' '/Cache restored from key:/ { print $2; exit }' run.log || echo "")
          fi
          echo "CACHE_NODE_BYTES=${BYTES}" >> "$GITHUB_ENV"
          echo "CACHE_NODE_KEY=${KEY}" >> "$GITHUB_ENV"
      - name: Install
        run: |
          ./scripts/install.sh
      - name: Build
        run: |
          ./scripts/build.sh
      - name: Test
        run: |
          ./scripts/test.sh
      - name: "CLI smoke: normalize | validate sample"
        run: |
          # build CLI if not already built by pretest
          npm run build --silent
          # normalize a sample and validate against the schema using built-in validator
          node dist/cli.js normalize \
            --in samples/workflow_run.completed.json \
            --out /tmp/out.validate.json
          node dist/cli.js validate \
            --in /tmp/out.validate.json \
            --schema docs/specs/ne.schema.json \
            --quiet
      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: |
            coverage/lcov.info
            coverage/coverage-summary.json
          if-no-files-found: ignore
      - name: Upload JUnit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vitest-junit
          path: |
            junit.xml
          if-no-files-found: ignore
      - name: Coverage summary
        if: always()
        run: |
          if [ -f coverage/coverage-summary.json ]; then
            node -e '
              const fs = require("fs");
              const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
              const t = sum.total || {};
              const row = (k) => `| ${k} | ${((t[k]?.pct ?? 0)).toFixed(2)}% | ${t[k]?.covered ?? 0}/${t[k]?.total ?? 0} |`;
              const out = [
                "## Coverage Summary",
                "",
                "| Metric | Percent | Covered/Total |",
                "|---|---:|---:|",
                row("lines"),
                row("statements"),
                row("functions"),
                row("branches"),
                "",
              ].join("\n");
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, out);
            ';
          else
            echo "coverage/coverage-summary.json not found; ensure vitest json-summary reporter is enabled" >> "$GITHUB_STEP_SUMMARY";
          fi
      - name: "PR feedback: coverage thresholds -> comment + labels"
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ ! -f coverage/coverage-summary.json ]; then
            echo "No coverage summary found; skipping PR feedback." >&2
            exit 0
          fi
          # Read vitest thresholds from config (hardcode fallback)
          LINES_T=60
          BRANCHES_T=55
          FUNCS_T=60
          STMTS_T=60
          # Parse actuals
          node -e '
            const fs = require("fs");
            const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
            const t = sum.total || {};
            const pct = {
              lines: Number((t.lines?.pct ?? 0).toFixed(2)),
              branches: Number((t.branches?.pct ?? 0).toFixed(2)),
              functions: Number((t.functions?.pct ?? 0).toFixed(2)),
              statements: Number((t.statements?.pct ?? 0).toFixed(2)),
            };
            fs.writeFileSync("/tmp/cov.json", JSON.stringify(pct));
          '
          read -r LINES_P BRANCHES_P FUNCS_P STMTS_P < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' /tmp/cov.json)
          FAILS=()
          cmp() { awk -v a="$1" -v b="$2" 'BEGIN{ if (a+0 < b+0) exit 1; else exit 0 }'; }
          cmp "$LINES_P" "$LINES_T" || FAILS+=("lines")
          cmp "$BRANCHES_P" "$BRANCHES_T" || FAILS+=("branches")
          cmp "$FUNCS_P" "$FUNCS_T" || FAILS+=("functions")
          cmp "$STMTS_P" "$STMTS_T" || FAILS+=("statements")
          STATUS=ok
          if [ ${#FAILS[@]} -gt 0 ]; then STATUS=low; fi
          LABEL_OK="coverage:ok"
          LABEL_LOW="coverage:low"
          PR_NUMBER=$(jq -r .pull_request.number < "$GITHUB_EVENT_PATH")
          REPO_FULL=${GITHUB_REPOSITORY}
          # Ensure labels exist
          gh label list --repo "$REPO_FULL" >/dev/null 2>&1 || true
          for L in "$LABEL_OK" "$LABEL_LOW"; do
            if ! gh label view "$L" --repo "$REPO_FULL" >/dev/null 2>&1; then
              gh label create "$L" --color $( [ "$L" = "$LABEL_OK" ] && echo 2eb886 || echo e11d21 ) --description "Test coverage ${L#coverage:}" --repo "$REPO_FULL" || true
            fi
          done
          # Update labels on PR
          if [ "$STATUS" = ok ]; then
            gh pr edit "$PR_NUMBER" --repo "$REPO_FULL" --add-label "$LABEL_OK" --remove-label "$LABEL_LOW" 2>/dev/null || true
          else
            gh pr edit "$PR_NUMBER" --repo "$REPO_FULL" --add-label "$LABEL_LOW" --remove-label "$LABEL_OK" 2>/dev/null || true
          fi
          # Prepare PR comment body with stable marker
          {
            echo "<!-- a5c:coverage-feedback -->"
            echo "## ðŸ§ª Coverage Feedback"
            echo "Status: ${STATUS}"
            echo ""
            echo "| Metric | Actual | Threshold |"
            echo "|---|---:|---:|"
            printf "| Lines | %s%% | %s%% |\n" "$LINES_P" "$LINES_T"
            printf "| Branches | %s%% | %s%% |\n" "$BRANCHES_P" "$BRANCHES_T"
            printf "| Functions | %s%% | %s%% |\n" "$FUNCS_P" "$FUNCS_T"
            printf "| Statements | %s%% | %s%% |\n" "$STMTS_P" "$STMTS_T"
            echo ""
            echo "_Automated feedback from Tests workflow._"
          } > /tmp/pr-comment.md
          # Find existing comment with marker and update; otherwise create
          existing_id=$(gh api \
            repos/${REPO_FULL}/issues/${PR_NUMBER}/comments \
            --jq '.[] | select(.body | contains("a5c:coverage-feedback")) | .id' || true)
          if [ -n "$existing_id" ]; then
            gh api \
              -X PATCH \
              -H "Accept: application/vnd.github+json" \
              repos/${REPO_FULL}/issues/comments/${existing_id} \
              -f body@/tmp/pr-comment.md >/dev/null
          else
            gh pr comment "$PR_NUMBER" --repo "$REPO_FULL" -F /tmp/pr-comment.md >/dev/null
          fi
      - name: Observability summary
        if: always()
        uses: ./.github/actions/obs-summary
        env:
          OBS_FILE: observability.json
          CACHE_NODE_HIT: ${{ steps.setup-node.outputs.cache-hit }}
          CACHE_NODE_BYTES: ${{ env.CACHE_NODE_BYTES }}
          CACHE_NODE_KEY: ${{ env.CACHE_NODE_KEY }}
          CONCLUSION: ${{ job.status }}
          RUN_STARTED_AT: ${{ github.run_started_at }}
      - name: Step hotspots summary
        if: always()
        uses: ./.github/actions/step-hotspots
        with:
          warn_ms: 300000
          error_ms: 900000
          p95_warn_ms: 420000
          p95_error_ms: 1200000
          top_n: 10
