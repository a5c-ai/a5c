name: "Observability Aggregate"
description: "Download artifacts from upstream jobs, aggregate basic metrics, write observability.aggregate.json, and upload it as an artifact"
author: "a5c.ai"
runs:
  using: "composite"
  steps:
    - name: Set defaults
      id: defaults
      shell: bash
      run: |
        set -euo pipefail
        : "${OUT:=observability.aggregate.json}"
        echo "OUT=${OUT}" >> "$GITHUB_ENV"

    # Download relevant artifacts from prior jobs (best-effort)
    - name: Download coverage artifact
      uses: actions/download-artifact@v4
      with:
        name: coverage
        path: _artifacts/coverage
      continue-on-error: true
    - name: Download junit artifact
      uses: actions/download-artifact@v4
      with:
        name: vitest-junit
        path: _artifacts/vitest-junit
      continue-on-error: true
    - name: Download observability JSON
      uses: actions/download-artifact@v4
      with:
        name: observability
        path: _artifacts/observability
      continue-on-error: true
    - name: Download vitest json
      uses: actions/download-artifact@v4
      with:
        name: vitest-json
        path: _artifacts/vitest-json
      continue-on-error: true

    - name: Aggregate to JSON
      id: aggregate
      shell: bash
      run: |
        set -euo pipefail
        OUT="${OUT:-observability.aggregate.json}"
        node -e '
          const fs = require("fs");
          const path = require("path");

          // Helper to safely read JSON
          const readJSON = (p) => { try { return JSON.parse(fs.readFileSync(p, "utf8")); } catch { return null; } };

          // Collect any coverage summaries found under downloaded artifacts
          const covFiles = [];
          const walk = (dir) => {
            try {
              for (const e of fs.readdirSync(dir, { withFileTypes: true })) {
                const p = path.join(dir, e.name);
                if (e.isDirectory()) walk(p);
                else if (/coverage-summary\.json$/.test(p)) covFiles.push(p);
              }
            } catch {}
          };
          walk(path.join(process.cwd(), "_artifacts"));

          const runs = [];
          for (const f of covFiles) {
            const sum = readJSON(f);
            if (!sum) continue;
            runs.push({
              source: path.relative(process.cwd(), f),
              metrics: { coverage: sum }
            });
          }

          // Attempt to read cache summary from any observability.json produced by obs-summary
          let cacheSummary = null;
          const obsJsons = [];
          const collectObs = (dir) => {
            try {
              for (const e of fs.readdirSync(dir, { withFileTypes: true })) {
                const p = path.join(dir, e.name);
                if (e.isDirectory()) collectObs(p);
                else if (e.isFile() && e.name === "observability.json") obsJsons.push(p);
              }
            } catch {}
          };
          collectObs(path.join(process.cwd(), "_artifacts"));
          for (const p of obsJsons) {
            const o = readJSON(p);
            const s = o?.metrics?.cache?.summary || o?.metrics?.cache; // tolerate either shape
            if (s && typeof s.total === "number") { cacheSummary = s; break; }
          }

          // Build aggregated coverage averages
          const pct = (t, key) => {
            const v = t?.[key]?.pct; return (typeof v === "number") ? v : undefined;
          };
          const totals = { lines: [], branches: [], functions: [], statements: [] };
          for (const r of runs) {
            const t = r?.metrics?.coverage?.total; if (!t) continue;
            for (const k of Object.keys(totals)) {
              const v = pct(t, k); if (typeof v === "number") totals[k].push(v);
            }
          }
          const avg = (arr) => arr.length ? Number((arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(2)) : undefined;
          const covAgg = {
            lines_avg_pct: avg(totals.lines),
            branches_avg_pct: avg(totals.branches),
            functions_avg_pct: avg(totals.functions),
            statements_avg_pct: avg(totals.statements),
          };
          const metrics = {};
          if (Object.values(covAgg).some(v => v != null)) metrics.coverage = covAgg;
          if (cacheSummary) metrics.cache = cacheSummary;

          const agg = { runs, metrics };
          fs.writeFileSync("observability.aggregate.json", JSON.stringify(agg, null, 2));
        '

    - name: Upload aggregate artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: observability-aggregate
        path: ${{ env.OUT }}

branding:
  icon: bar-chart-2
  color: blue
