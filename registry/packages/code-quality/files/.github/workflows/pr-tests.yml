name: PR Quick Tests

on:
  pull_request:
    branches: [a5c/main, main]
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - "docs/**"
      - ".github/**"

concurrency:
  group: pr-tests-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  vitest:
    name: Unit Tests (PR) - Node v${{ matrix.node-version }}
    runs-on: ubuntu-latest
    timeout-minutes: 6
    strategy:
      fail-fast: false
      matrix:
        node-version: [20, 22]
    env:
      # Optional: enable Codecov uploads when token is set (secret or variable)
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN || vars.CODECOV_TOKEN || '' }}
      # Hard coverage gate is now opt-in for PRs. To enable, set repository
      # variable REQUIRE_COVERAGE='true'. By default it is not enforced in PR
      # Quick Tests to keep checks fast and non-blocking.
      REQUIRE_COVERAGE: ${{ vars.REQUIRE_COVERAGE == 'true' && 'true' || '' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm
      - name: Install
        run: npm ci
      - name: Test (vitest, coverage)
        run: npm run -s test:ci
      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pr-coverage-lcov-node-${{ matrix.node-version }}
          path: |
            coverage/lcov.info
            coverage/coverage-summary.json
      - name: Upload to Codecov (optional)
        # Upload to Codecov only when CODECOV_TOKEN is configured
        if: env.CODECOV_TOKEN != ''
        uses: codecov/codecov-action@v5
        with:
          token: ${{ env.CODECOV_TOKEN }}
          files: |
            coverage/lcov.info
          flags: pr-node-${{ matrix.node-version }}
          fail_ci_if_error: false
          verbose: true
      - name: "PR feedback: coverage thresholds -> comment + labels"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ ! -f coverage/coverage-summary.json ]; then
            echo "No coverage summary found; skipping PR feedback." >&2
            exit 0
          fi
          # Read thresholds from single source JSON (fallback to defaults)
          if [ -f scripts/coverage-thresholds.json ]; then
            read -r LINES_T BRANCHES_T FUNCS_T STMTS_T < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' scripts/coverage-thresholds.json)
          else
            LINES_T=60
            BRANCHES_T=55
            FUNCS_T=60
            STMTS_T=60
          fi
          # Parse actuals
          node -e '
            const fs = require("fs");
            const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
            const t = sum.total || {};
            const pct = {
              lines: Number((t.lines?.pct ?? 0).toFixed(2)),
              branches: Number((t.branches?.pct ?? 0).toFixed(2)),
              functions: Number((t.functions?.pct ?? 0).toFixed(2)),
              statements: Number((t.statements?.pct ?? 0).toFixed(2)),
            };
            fs.writeFileSync("/tmp/cov.json", JSON.stringify(pct));
          '
          read -r LINES_P BRANCHES_P FUNCS_P STMTS_P < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' /tmp/cov.json)
          FAILS=()
          cmp() { awk -v a="$1" -v b="$2" 'BEGIN{ if (a+0 < b+0) exit 1; else exit 0 }'; }
          cmp "$LINES_P" "$LINES_T" || FAILS+=("lines")
          cmp "$BRANCHES_P" "$BRANCHES_T" || FAILS+=("branches")
          cmp "$FUNCS_P" "$FUNCS_T" || FAILS+=("functions")
          cmp "$STMTS_P" "$STMTS_T" || FAILS+=("statements")
          STATUS=ok
          if [ ${#FAILS[@]} -gt 0 ]; then STATUS=low; fi
          LABEL_OK="coverage:ok"
          LABEL_LOW="coverage:low"
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO_FULL=${GITHUB_REPOSITORY}
          # Ensure labels exist
          gh label list --repo "$REPO_FULL" >/dev/null 2>&1 || true
          for L in "$LABEL_OK" "$LABEL_LOW"; do
            if ! gh label view "$L" --repo "$REPO_FULL" >/dev/null 2>&1; then
              gh label create "$L" --color $( [ "$L" = "$LABEL_OK" ] && echo 2eb886 || echo e11d21 ) --description "Test coverage ${L#coverage:}" --repo "$REPO_FULL" || true
            fi
          done
          # Update labels on PR
          if [ "$STATUS" = ok ]; then
            gh pr edit "$PR_NUMBER" --repo "$REPO_FULL" --add-label "$LABEL_OK" --remove-label "$LABEL_LOW" 2>/dev/null || true
          else
            gh pr edit "$PR_NUMBER" --repo "$REPO_FULL" --add-label "$LABEL_LOW" --remove-label "$LABEL_OK" 2>/dev/null || true
          fi
          # Prepare PR comment body with stable marker
          {
            echo "<!-- a5c:coverage-feedback -->"
            echo "## ðŸ§ª Coverage Feedback"
            echo "Status: ${STATUS} (Node ${{ matrix.node-version }})"
            echo ""
            echo "| Metric | Actual | Threshold |"
            echo "|---|---:|---:|"
            printf "| Lines | %s%% | %s%% |\n" "$LINES_P" "$LINES_T"
            printf "| Branches | %s%% | %s%% |\n" "$BRANCHES_P" "$BRANCHES_T"
            printf "| Functions | %s%% | %s%% |\n" "$FUNCS_P" "$FUNCS_T"
            printf "| Statements | %s%% | %s%% |\n" "$STMTS_P" "$STMTS_T"
            echo ""
            echo "_Automated feedback from PR Quick Tests._"
          } > /tmp/pr-comment.md
          # Upsert comment with stable marker
          existing_id=$(gh api \
            repos/${REPO_FULL}/issues/${PR_NUMBER}/comments \
            --jq '.[] | select(.body | contains("a5c:coverage-feedback")) | .id' || true)
          if [ -n "$existing_id" ]; then
            gh api \
              -X PATCH \
              -H "Accept: application/vnd.github+json" \
              repos/${REPO_FULL}/issues/comments/${existing_id} \
              -F body=@/tmp/pr-comment.md >/dev/null
          else
            gh pr comment "$PR_NUMBER" --repo "$REPO_FULL" -F /tmp/pr-comment.md >/dev/null
          fi
      - name: "Coverage gate (optional, REQUIRE_COVERAGE)"
        if: ${{ env.REQUIRE_COVERAGE == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "REQUIRE_COVERAGE=true -> enforcing thresholds from scripts/coverage-thresholds.json"
          if [ ! -f coverage/coverage-summary.json ]; then
            echo "::error title=Coverage Gate Failed::coverage/coverage-summary.json not found. Ensure tests generate coverage with json-summary reporter."
            exit 1
          fi
          if [ ! -f scripts/coverage-thresholds.json ]; then
            echo "::error title=Coverage Gate Failed::scripts/coverage-thresholds.json not found. Thresholds must be defined."
            exit 1
          fi
          # Load thresholds from single source of truth
          read -r LINES_T BRANCHES_T FUNCS_T STMTS_T < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' scripts/coverage-thresholds.json)
          # Extract actuals
          node -e '
            const fs = require("fs");
            const sum = JSON.parse(fs.readFileSync("coverage/coverage-summary.json","utf8"));
            const t = sum.total || {};
            const pct = {
              lines: Number((t.lines?.pct ?? 0).toFixed(2)),
              branches: Number((t.branches?.pct ?? 0).toFixed(2)),
              functions: Number((t.functions?.pct ?? 0).toFixed(2)),
              statements: Number((t.statements?.pct ?? 0).toFixed(2)),
            };
            fs.writeFileSync("/tmp/cov.json", JSON.stringify(pct));
          '
          read -r LINES_P BRANCHES_P FUNCS_P STMTS_P < <(jq -r '[.lines,.branches,.functions,.statements] | @tsv' /tmp/cov.json)
          # Compare helper (numeric less-than detection)
          cmp() { awk -v a="$1" -v b="$2" 'BEGIN{ if (a+0 < b+0) exit 1; else exit 0 }'; }
          FAILS=()
          cmp "$LINES_P" "$LINES_T" || FAILS+=("lines: ${LINES_P}% < ${LINES_T}%")
          cmp "$BRANCHES_P" "$BRANCHES_T" || FAILS+=("branches: ${BRANCHES_P}% < ${BRANCHES_T}%")
          cmp "$FUNCS_P" "$FUNCS_T" || FAILS+=("functions: ${FUNCS_P}% < ${FUNCS_T}%")
          cmp "$STMTS_P" "$STMTS_T" || FAILS+=("statements: ${STMTS_P}% < ${STMTS_T}%")
          {
            echo "## Coverage Gate"
            echo "REQUIRE_COVERAGE=true; failing when below thresholds"
            echo ""
            echo "| Metric | Actual | Threshold |"
            echo "|---|---:|---:|"
            printf "| Lines | %s%% | %s%% |\n" "$LINES_P" "$LINES_T"
            printf "| Branches | %s%% | %s%% |\n" "$BRANCHES_P" "$BRANCHES_T"
            printf "| Functions | %s%% | %s%% |\n" "$FUNCS_P" "$FUNCS_T"
            printf "| Statements | %s%% | %s%% |\n" "$STMTS_P" "$STMTS_T"
            if [ ${#FAILS[@]} -gt 0 ]; then
              echo ""
              echo "Failures: ${FAILS[*]}"
            else
              echo ""
              echo "All metrics meet or exceed thresholds."
            fi
          } | tee -a "$GITHUB_STEP_SUMMARY"
          if [ ${#FAILS[@]} -gt 0 ]; then
            echo "::error title=Coverage Gate Failed::Below thresholds for: ${FAILS[*]}"
            echo "Coverage below thresholds; failing per REQUIRE_COVERAGE=true" >&2
            exit 1
          fi

  smoke-cli:
    name: CLI Smoke - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 5
    strategy:
      fail-fast: true
      matrix:
        os: [windows-latest, macos-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: npm
      - name: Install
        run: npm ci
      - name: Build
        run: npm run -s build
      - name: CLI --help
        run: node dist/cli.js --help
      - name: CLI normalize --help
        run: node dist/cli.js normalize --help

  release-dry-run:
    name: Semantic Release (dry-run)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout full history
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: npm
      - name: Install (no hooks)
        env:
          HUSKY: 0
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm install; fi
      - name: Dry-run semantic-release
        id: semrel
        env:
          GITHUB_TOKEN: ${{ secrets.A5C_AGENT_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          HUSKY: 0
        run: |
          set -euo pipefail
          # Perform dry-run and capture summary
          npx semantic-release --dry-run --no-ci 2>&1 | tee /tmp/semrel.log || true
          # Extract next release info if available
          NEXT_VERSION=$(grep -Eo 'The next release version is [0-9]+\.[0-9]+\.[0-9]+' /tmp/semrel.log | awk '{print $6}' | tail -n1 || true)
          NEXT_TYPE=$(grep -Eo 'The next release type is (major|minor|patch)' /tmp/semrel.log | awk '{print $6}' | tail -n1 || true)
          echo "next_version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "next_type=${NEXT_TYPE}" >> "$GITHUB_OUTPUT"
      - name: Comment on PR with prediction
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO_FULL=${GITHUB_REPOSITORY}
          {
            echo "<!-- a5c:semrel-dry-run -->"
            echo "## ðŸ“¦ Release Preview (dry-run)"
            if [ -n "${{ steps.semrel.outputs.next_version }}" ]; then
              echo "Next version: <code>${{ steps.semrel.outputs.next_version }}</code> (${{ steps.semrel.outputs.next_type }})"
            else
              echo "No release predicted (no release-worthy commits)."
            fi
            echo
            echo "_This is a non-blocking dry-run of semantic-release._"
          } > /tmp/semrel-comment.md
          # Upsert comment with stable marker
          existing_id=$(gh api \
            repos/${REPO_FULL}/issues/${PR_NUMBER}/comments \
            --jq '.[] | select(.body | contains("a5c:semrel-dry-run")) | .id' || true)
          if [ -n "$existing_id" ]; then
            gh api -X PATCH -H "Accept: application/vnd.github+json" \
              repos/${REPO_FULL}/issues/comments/${existing_id} \
              -F body=@/tmp/semrel-comment.md >/dev/null
          else
            gh pr comment "$PR_NUMBER" --repo "$REPO_FULL" -F /tmp/semrel-comment.md >/dev/null
          fi
